---
description: 
globs: 
alwaysApply: true
---
 Architecture & Structure
Use nwidart/laravel-modules for modular structure.

Each module must be fully isolated and contain:

Models

Controllers

Services

Repositories (with interfaces)

FormRequests

Routes (registered via RouteServiceProvider)

Service Providers

The core Laravel app should remain as thin as possible ‚Äî business logic must live in modules.

No circular dependencies between modules.

Avoid duplicate logic ‚Äî always abstract common flows into Services or Traits.

üß† Design & Code Quality
Follow the Service + Repository Pattern precisely:

Repositories contain only data access logic.

Services contain only business logic and orchestrate use cases.

Apply all SOLID principles without compromise.

Use proper OOP design patterns where applicable (e.g., Strategy, Factory, Decorator).

Code must follow PSR-12, be clean, readable, testable, and maintainable.

All naming conventions (classes, methods, variables) must be clear, meaningful, and context-aware.

Eliminate code repetition; follow DRY and KISS principles.

Controllers must act only as request dispatchers, delegating to services.

No logic in routes. No queries or business logic in controllers.

üîê Security (Top-Level)
Use Laravel Sanctum for all API authentication ‚Äî every route must be protected.

Roles and permissions must be managed via Spatie Laravel Permission.

Apply permission checks using middleware (auth:sanctum, role, permission, and custom ones if needed).

Validate all user input using FormRequest classes.

Never trust client input ‚Äî always sanitize, even post-validation.

Escape any output used in HTML rendering.

NEVER use raw SQL queries, dynamic function calls, or any kind of unsafe code execution (e.g., eval, exec).

Rate limiting and throttling should be applied to critical routes (login, auth, etc.).

Implement fallback responses for failed or unauthorized access.

Ensure all tokens and sessions are securely stored and handled.

Apply strict CORS and CSRF policies where applicable.

Log sensitive actions (login, password reset, permission changes).

Never expose exception messages or stack traces to users.

üì¶ API Response Standards
Use a shared, global ApiResponse trait to standardize all JSON responses.

All API responses must return:

success (bool)

message (string)

data (nullable object/array)

errors (nullable array)

Use accurate HTTP status codes (200, 401, 403, 404, 422, 500).

Never return raw exceptions or DB errors in API responses.

Ensure all responses are localized and user-friendly when needed.

üîÑ Routing & Middleware
Each module must define its own routes under routes/api.php.

Register all routes via the module‚Äôs own RouteServiceProvider.

Apply route middleware for authentication and permission access at the group or route level.

Implement and use custom middleware when needed (e.g., access filters, user state checks, API guards).

Middleware must be used to prevent any unauthorized access before controller logic is triggered.

üóÑ Database & Migrations
Do not modify existing migrations ‚Äî always create a new one when schema changes are needed.

Use strict schema rules, types, and indexes where performance matters.

Always include down() methods for rollback support.

Use foreign key constraints and onDelete('cascade') only where appropriate.

Maintain a migration versioning and documentation strategy.

üìö Testing & Quality
Write feature and unit tests for all business-critical flows.

Use Laravel‚Äôs testing tools (TestCase, RefreshDatabase, etc.).

Include validation and edge-case coverage.

Services and Repositories must be easily testable with mocks.

Avoid tightly coupled code ‚Äî prefer constructor injection and interfaces.

üîß DevOps & Readiness
All .env secrets must never be exposed or committed.

Use .env.example with sensible defaults.

Configure logging channels and log levels appropriately.

Enable exception reporting via services like Sentry, Bugsnag, or similar in production.

Ensure all modules are auto-loaded correctly in composer.json.

‚úÖ Final Notes
Always write code as if other engineers will maintain it.

Maintain high readability, full modularity, and strong separation of concerns.

Prioritize security, performance, testability, and long-term maintainability.


This backend must reflect the standard of a world-class Laravel engineer.